<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Арабский тренажёр</title>

  <script defer src="https://cloud.umami.is/script.js" data-website-id="a21e0a1b-d541-42d5-a46a-593c803caf8d"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width:900px; margin:auto; }
    #intro { background: #fff; padding:16px; border-radius:8px; border:1px solid #ddd; margin-bottom:16px; }
    #dua { direction: rtl; font-size:2em; margin:12px 0; font-weight:600; }
    #arabicWord { font-size:2rem; direction: rtl; margin:12px 0; font-weight:600; text-align:right; }
    input[type="text"]{ width:100%; padding:8px; font-size:1rem; box-sizing:border-box; }
    button{ padding:8px 12px; margin-top:8px; }
    textarea { width:100%; box-sizing:border-box; padding:8px; font-size:0.95rem; resize:vertical; }
    #correct-list { min-height:60px; font-weight:700; background:#fffdf5; border:1px solid #e0d7c2; }
    #mistake-list { min-height:120px; font-weight:400; background:#f9f9f9; border:1px solid #ddd; }
    .btn-row { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }
    #controls, #trainer { margin-top:16px; }
    .small { font-size:0.9rem; color:#444; margin-top:6px; }
    .hidden { display:none; }
    h3 { margin-bottom:6px; margin-top:16px; }

    /* modal for wrong answer */
    .overlay { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; z-index:1000; }
    .modal { background:white; padding:20px; border-radius:8px; max-width:500px; width:90%; box-shadow:0 6px 20px rgba(0,0,0,0.2); }
    .modal h2 { margin-top:0; }
    .modal p { margin:8px 0; }
    .modal .correct { direction: rtl; font-size:1.4em; font-weight:600; margin:10px 0; }
  </style>
</head>
<body>
  <!-- Начальный экран с дуа -->
  <div id="intro">
    <h1>Перед началом тренировок</h1>
    <p>Дуа:</p>
    <div id="dua">رَّبِّ زِدْنِى عِلْمًۭا</div>
    <p>Перевод: «Господь мой! Приумножь мои знания»</p>
    <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
      <button id="doneDua">Я сделал дуа</button>
    </div>
  </div>

  <!-- Основной интерфейс -->
  <div id="main" class="hidden">
    <h1>Арабский тренажёр</h1>

    <div id="progress" class="small"></div>
    <div id="arabicWord"></div>

    <input id="userInput" type="text" placeholder="Введите перевод на русском">
    <br>
    <button id="submitBtn">Ответить</button>

    <h3>Правильно:</h3>
    <textarea id="correct-list" readonly placeholder="Здесь будут верные ответы..."></textarea>

    <h3>Ошибки:</h3>
    <textarea id="mistake-list" readonly placeholder="Здесь будут ваши ошибки..."></textarea>

    <div class="btn-row">
      <button id="copyMistakesBtn">Копировать ошибки</button>
      <button id="startMistakesBtn" class="hidden">Работа над ошибками</button>
      <button id="addNewBtn">Добавить новые слова</button>
      <button id="resetBtn">Сбросить прогресс</button>
    </div>
  </div>

  <!-- Modal placeholder -->
  <div id="modal-root"></div>

<script>
  // ====== Основные структуры ======
  let words = []; // { rawLine, ruVariants:[], arFull }
  let orderRaw = []; // remaining rawLines (те, что в очереди)
  let currentRaw = null;
  let mistakes = [];
  let correctLines = [];
  let mode = 'all';
  let modalTimeout = null;

  const STORAGE_KEY = (() => {
    const path = (location.pathname || '/').replace(/^\/|\/$/g,'').replace(/\//g,'_') || 'root';
    return `arabic_trainer_state_v1_${encodeURIComponent(location.hostname + '_' + path)}`;
  })();

  // ====== Вспомогательные функции ======
  function parseLine(line) {
    const raw = (line||'').trim();
    const parts = raw.split(/[-–—]/);
    const ruPart = (parts[0] || '').trim();
    const arabicParts = parts.slice(1).map(p => p.trim()).filter(p => p);
    const ruVariants = ruPart ? ruPart.split(',').map(r => r.trim()).filter(Boolean).map(r => r.toLowerCase()) : [];
    const arFull = arabicParts.join(' - ');
    return { rawLine: raw, ruVariants, arFull };
  }

  function shuffleArray(a){
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  function normalizeRu(s) { return String(s||'').trim().toLowerCase().replace(/ё/g, 'е'); }
  function escapeHtml(s) { return String(s||'').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'})[c]); }

  // ====== НОВАЯ ФУНКЦИЯ: Сравнение слов по содержимому ======
  function getWordContentHash(wordObj) {
    const ruContent = (wordObj.ruVariants || []).join('|');
    const arContent = wordObj.arFull;
    return `${ruContent}|||${arContent}`;
  }

  // ====== Частичная ошибка: проверка последнего символа ======
  function isLastCharMistake(inputRaw, targetRaw){
    if(!inputRaw || !targetRaw) return false;
    const input = normalizeRu(inputRaw);
    const target = normalizeRu(targetRaw);
    if(!input || !target) return false;
    if(input === target) return false;
    if(input === target.slice(0, -1)) return true;
    if(input.length === target.length && input.slice(0, -1) === target.slice(0, -1)) return true;
    if(input.length === target.length - 1 && target.startsWith(input)) return true;
    return false;
  }

  // ====== Сохранение/восстановление состояния ======
  function saveState() {
    try {
      const state = {
        ts: Date.now(),
        orderRaw: orderRaw.slice(),
        currentRaw,
        mistakes: mistakes.slice(),
        correctLines: correctLines.slice(),
        mode,
        wordsList: words.map(w => w.rawLine)
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) { console.warn('saveState failed', e); }
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) { return null; }
  }

  function clearSavedState() { localStorage.removeItem(STORAGE_KEY); }

  // ====== robust fetch ======
  async function robustFetchWords(){
    const timestamp = Date.now();
    const tries = ['words.txt','./words.txt'];
    try{ tries.push(location.pathname.replace(/\/[^/]*$/,'/') + 'words.txt'); }catch(e){}
    for(const p of tries){
      try{ const r = await fetch(p + '?_' + timestamp, {cache: 'no-store'}); if(r.ok) return await r.text(); }catch(e){}
    }
    try{
      const user = location.hostname.split('.')[0] || '';
      const repo = (location.pathname.split('/').filter(Boolean)[0] || '');
      if(user && repo){
        const raw = `https://raw.githubusercontent.com/${user}/${repo}/main/words.txt`;
        const r = await fetch(raw + '?_' + timestamp, {cache: 'no-store'});
        if(r.ok) return await r.text();
      }
    }catch(e){}
    throw new Error('Не удалось загрузить words.txt');
  }

  // ====== Order / nextWord ======
  function prepareOrder(source='all') {
    if (source === 'all') {
      orderRaw = words.map(w => w.rawLine);
      shuffleArray(orderRaw);
      mode = 'all';
    } else if (source === 'mistakes') {
      orderRaw = mistakes.filter(r => words.some(w => w.rawLine === r)).slice();
      shuffleArray(orderRaw);
      mode = 'mistakes';
    }
    saveState();
  }

  function nextWord() {
    if (!orderRaw || orderRaw.length === 0) {
      if (mode === 'mistakes' && (!mistakes || mistakes.length === 0)) {
        document.getElementById('arabicWord').textContent = 'Ошибок нет.';
        updateProgress();
        return;
      }
      prepareOrder(mode === 'mistakes' ? 'mistakes' : 'all');
    }
    if (orderRaw.length === 0) {
      document.getElementById('arabicWord').textContent = 'Нет слов для тренировки.';
      updateProgress();
      return;
    }

    const raw = orderRaw.shift();
    currentRaw = raw;
    saveState();

    const w = words.find(w => w.rawLine === raw) || { rawLine: raw, ruVariants: [], arFull: raw };
    if (!w.arFull || !w.arFull.trim()) {
      // логируем в консоль: позволит быстро выяснить "нет арабского формата"
      console.warn('No arabic format for', raw, w);
    }
    document.getElementById('arabicWord').textContent = w.arFull || w.rawLine;
    updateProgress();
    document.getElementById('userInput').value = '';
    document.getElementById('userInput').focus();
    return w;
  }

  // ====== Завершение / прогресс ======
  function finishSession() {
    const total = words.length || 0;
    const done = total - (orderRaw ? orderRaw.length : 0);
    document.getElementById('arabicWord').textContent = `Готово! Пройдено ${done}/${total} слов – ошибок: ${mistakes.length}`;
    const btn = document.getElementById('startMistakesBtn');
    if (mistakes.length) btn.classList.remove('hidden'); else btn.classList.add('hidden');
    currentRaw = null;
    saveState();
    updateProgress();
  }

  function updateProgress() {
    const total = words.length || 0;
    const remaining = orderRaw.length || 0;
    const done = total - remaining;
    document.getElementById('progress').textContent = `${done}/${total} слов пройдено – ${mistakes.length} ошибок`;
  }

  // ====== Модалки ======
  function showInfoModal(title, bodyHtml, afterCloseCallback, autoCloseMs = 5000) {
    closeModal();
    const root = document.getElementById('modal-root');
    const overlay = document.createElement('div'); overlay.className = 'overlay';
    const modal = document.createElement('div'); modal.className = 'modal';
    modal.setAttribute('role','dialog'); modal.setAttribute('aria-modal','true');
    modal.innerHTML = `<h2>${escapeHtml(title)}</h2><div>${bodyHtml}</div><div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;"><button id="modalCloseBtn">Закрыть (Esc)</button></div>`;
    overlay.appendChild(modal); root.appendChild(overlay);

    function cleanup() {
      if (modalTimeout) { clearTimeout(modalTimeout); modalTimeout = null; }
      document.removeEventListener('keydown', onKey);
      const btn = document.getElementById('modalCloseBtn'); if (btn) btn.removeEventListener('click', onBtn);
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
    }
    function onKey(e) { if (e.key === 'Escape') { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); } }
    function onBtn() { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); }

    document.addEventListener('keydown', onKey);
    const btn = document.getElementById('modalCloseBtn'); if (btn) btn.addEventListener('click', onBtn);

    modalTimeout = setTimeout(() => { cleanup(); if (typeof afterCloseCallback === 'function') afterCloseCallback(); }, autoCloseMs);
  }

  function showWrongModal(correctText, afterCloseCallback) {
    showInfoModal('Неправильно', `<div>Правильный ответ:</div><div class="correct">${escapeHtml(correctText)}</div>`, afterCloseCallback, 17000);
  }

  function showPartialModal(correctText, afterCloseCallback) {
    showInfoModal('Почти правильно — засчитано как верный ответ', `<div>Полный правильный ответ:</div><div class="correct">${escapeHtml(correctText)}</div>`, afterCloseCallback, 5000);
  }

  function closeModal() { const root = document.getElementById('modal-root'); root.innerHTML = ''; if (modalTimeout) { clearTimeout(modalTimeout); modalTimeout = null; } }

  // ====== НОВАЯ: Модал подтверждения сброса ======
  function showResetModal() {
    closeModal();
    const overlay = document.createElement('div'); overlay.className = 'overlay';
    const modal = document.createElement('div'); modal.className = 'modal';
    modal.innerHTML = `
      <div><strong>Подтверждение сброса</strong></div>
      <div style="margin-top:12px">Вы уверены? Все выученные слова и прогресс будут потеряны. Это действие нельзя отменить.</div>
      <div style="text-align:right;margin-top:16px">
        <button id="modal-cancel" style="margin-right:8px">Отмена</button>
        <button id="modal-confirm" style="background:#fff0f0;border-color:#f0b6b6">Да, сбросить</button>
      </div>
    `;
    overlay.appendChild(modal);
    document.getElementById('modal-root').appendChild(overlay);

    function cleanup() {
      document.removeEventListener('keydown', onKey);
      overlay.removeEventListener('click', onOverlay);
      const cancelBtn = document.getElementById('modal-cancel');
      const confirmBtn = document.getElementById('modal-confirm');
      if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);
      if (confirmBtn) confirmBtn.removeEventListener('click', onConfirm);
      if(overlay.parentNode) overlay.parentNode.removeChild(overlay);
    }
    function onKey(e) { if (e.key === 'Escape') onCancel(); }
    function onOverlay(e) { if (e.target === overlay) onCancel(); }
    function onCancel() { cleanup(); }
    async function onConfirm() {
      cleanup();
      // Выполнить сброс - загружаем все слова с сервера заново
      clearSavedState();
      try {
        const txt = await robustFetchWords();
        const serverLines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
        words = serverLines.map(l => parseLine(l));
        prepareOrder('all');
        mistakes = []; correctLines = []; currentRaw = null; mode = 'all';
        document.getElementById('correct-list').value = '';
        document.getElementById('mistake-list').value = '';
        document.getElementById('main').classList.add('hidden');
        document.getElementById('intro').classList.remove('hidden');
        saveState();
        updateProgress();
      } catch (err) {
        alert('Не удалось загрузить words.txt: ' + err);
      }
    }

    document.addEventListener('keydown', onKey);
    overlay.addEventListener('click', onOverlay);
    document.getElementById('modal-cancel').addEventListener('click', onCancel);
    document.getElementById('modal-confirm').addEventListener('click', onConfirm);
  }

  // ====== Проверка ответа (и запись) ======
  function checkAnswer() {
    if (!currentRaw) return;
    const inputRaw = document.getElementById('userInput').value;
    const input = normalizeRu(inputRaw);
    if (!input) return;
    const wObj = words.find(w => w.rawLine === currentRaw) || { ruVariants: [] };

    const exactOk = (wObj.ruVariants || []).some(v => normalizeRu(v) === input || normalizeRu(v) === input.replace(/е/g,'ё'));
    if (exactOk) {
      if (!correctLines.includes(wObj.rawLine)) correctLines.push(wObj.rawLine);
      document.getElementById('correct-list').value = correctLines.join('\n');
      saveState();
      currentRaw = null;
      if (!orderRaw || orderRaw.length === 0) finishSession(); else nextWord();
      return;
    }

    const partialOk = (wObj.ruVariants || []).some(v => isLastCharMistake(input, v));
    if (partialOk) {
      if (!correctLines.includes(wObj.rawLine)) correctLines.push(wObj.rawLine);
      document.getElementById('correct-list').value = correctLines.join('\n');
      saveState();
      const correctText = wObj.rawLine || currentRaw;
      showPartialModal(correctText, () => {
        currentRaw = null;
        if (!orderRaw || orderRaw.length === 0) finishSession(); else nextWord();
      });
      return;
    }

    if (!mistakes.includes(currentRaw)) mistakes.push(currentRaw);
    document.getElementById('mistake-list').value = mistakes.join('\n');
    saveState();
    const correctText = wObj.rawLine || currentRaw;
    showWrongModal(correctText, () => {
      currentRaw = null;
      if (!orderRaw || orderRaw.length === 0) finishSession(); else nextWord();
    });
  }

  // ====== Добавить новые слова (только по кнопке) ======
  async function addNewWords() {
    try {
      const txt = await robustFetchWords();
      const serverLines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
      const existing = new Set(words.map(w => w.rawLine));
      const newly = serverLines.filter(r => !existing.has(r));
      if (!newly.length) { alert('Новых слов не найдено.'); return; }
      const newObjs = newly.map(l => parseLine(l));
      for (const obj of newObjs) words.push(obj);
      for (const raw of newly) {
        if (!orderRaw.includes(raw) && currentRaw !== raw) {
          const pos = Math.floor(Math.random() * (orderRaw.length + 1));
          orderRaw.splice(pos, 0, raw);
        }
      }
      saveState(); updateProgress();
      alert('Добавлено ' + newly.length + ' новых слов. Они будут заданы в случайных местах очереди.');
    } catch (err) {
      alert('Не удалось загрузить words.txt: ' + err);
    }
  }

  // ====== Сброс прогресса (полный) ======
  // Теперь вызывается через модал showResetModal

  // ====== Копирование ошибок ======
  function copyTextToClipboard(text, msg) {
    if (!text) { alert('Нет данных для копирования.'); return; }
    navigator.clipboard.writeText(text).then(()=> alert(msg)).catch(()=> {
      const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); alert(msg); } catch(e) { alert('Не удалось скопировать'); } ta.remove();
    });
  }

  // ====== ИСПРАВЛЕННАЯ: Загрузка слов и восстановление состояния ======
  async function loadWords() {
    try {
      const txt = await robustFetchWords();
      const serverLines = txt.split(/\r?\n/).map(s => s.trim()).filter(s => s);
      const serverWords = serverLines.map(l => parseLine(l));

      // load saved state if exists
      const st = loadState();
      
      if (st && Array.isArray(st.wordsList) && st.wordsList.length) {
        // Восстанавливаем words из сохраненных rawLine
        words = st.wordsList.map(raw => {
          const parsed = parseLine(raw);
          return { rawLine: raw, ...parsed };
        });
        
        // Мапы для поиска
        const serverRawSet = new Set(serverLines);
        
        // 1. Удаленные слова - убираем из words и всех списков
        words = words.filter(w => serverRawSet.has(w.rawLine));
        
        orderRaw = (Array.isArray(st.orderRaw) ? st.orderRaw.filter(r => serverRawSet.has(r)) : []);
        mistakes = (Array.isArray(st.mistakes) ? st.mistakes.filter(r => serverRawSet.has(r)) : []);
        correctLines = (Array.isArray(st.correctLines) ? st.correctLines.filter(r => serverRawSet.has(r)) : []);
        currentRaw = (st.currentRaw && serverRawSet.has(st.currentRaw)) ? st.currentRaw : null;
        mode = st.mode || 'all';
        
        // 2. Измененные слова - обновляем в words и сбрасываем прогресс
        const serverByRaw = new Map(serverWords.map(w => [w.rawLine, w]));
        const changedWords = [];
        
        words.forEach((existingWord, index) => {
          const serverWord = serverByRaw.get(existingWord.rawLine);
          if (serverWord && getWordContentHash(existingWord) !== getWordContentHash(serverWord)) {
            // Обновляем
            words[index] = serverWord;
            changedWords.push(serverWord.rawLine);
          }
        });
        
        // Сбрасываем прогресс для измененных: убираем из correct/mistakes, добавляем в начало orderRaw
        changedWords.forEach(rawLine => {
          correctLines = correctLines.filter(r => r !== rawLine);
          mistakes = mistakes.filter(r => r !== rawLine);
          if (!orderRaw.includes(rawLine)) {
            orderRaw.unshift(rawLine); // В начало очереди
          }
        });
        
        // НЕ добавляем новые слова автоматически
        
      } else {
        // Fresh init - добавляем все слова с сервера
        words = serverWords.slice();
        prepareOrder('all');
      }
      
      document.getElementById('mistake-list').value = mistakes.join('\n');
      document.getElementById('correct-list').value = correctLines.join('\n');
      
      // Показываем intro, пользователь кликнет "Я сделал дуа"
      document.getElementById('intro').classList.remove('hidden');
      document.getElementById('main').classList.add('hidden');
      updateProgress();
      saveState();
      
    } catch (err) {
      document.getElementById('arabicWord').textContent = 'Не удалось загрузить words.txt: ' + err;
      console.error(err);
    }
  }

  // ====== Обработчики UI ======
  document.getElementById('doneDua').addEventListener('click', () => {
    document.getElementById('intro').classList.add('hidden');
    document.getElementById('main').classList.remove('hidden');
    if (currentRaw) {
      const w = words.find(w => w.rawLine === currentRaw) || { rawLine: currentRaw, arFull: currentRaw };
      document.getElementById('arabicWord').textContent = w.arFull || w.rawLine;
      updateProgress();
      document.getElementById('userInput').value = '';
      document.getElementById('userInput').focus();
    } else {
      nextWord();
    }
  });

  document.getElementById('submitBtn').addEventListener('click', checkAnswer);
  document.getElementById('userInput').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); checkAnswer(); }});
  document.getElementById('copyMistakesBtn').addEventListener('click', () => { copyTextToClipboard(mistakes.join('\n'), 'Ошибки скопированы'); });
  document.getElementById('startMistakesBtn').addEventListener('click', () => {
    if (!mistakes.length) return;
    prepareOrder('mistakes');
    document.getElementById('correct-list').value = '';
    document.getElementById('mistake-list').value = mistakes.join('\n');
    mode = 'mistakes';
    saveState();
    nextWord();
  });
  document.getElementById('addNewBtn').addEventListener('click', addNewWords);
  document.getElementById('resetBtn').addEventListener('click', showResetModal);
  window.addEventListener('beforeunload', saveState);

  // старт загрузки
  loadWords();
</script>
</body>
</html>
