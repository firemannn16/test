<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Тренажёр арабских слов — обновлённый</title>
<script defer src="https://cloud.umami.is/script.js" data-website-id="eb716e2e-5303-4a59-b38a-f4fd1d6d552a"></script>
<script type="module">
/* ---------- Firebase инициализация ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBM9YxHpD79wLzX33ya_6vZX1tC4d46Wfk",
  authDomain: "arabic-31a1a.firebaseapp.com",
  projectId: "arabic-31a1a",
  storageBucket: "arabic-31a1a.firebasestorage.app",
  messagingSenderId: "892431750830",
  appId: "1:892431750830:web:cbe977cc62d9851a4e7f3f"
};
try {
  const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
  const { getFirestore } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
  const { getAuth, signInAnonymously, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js'); // ИЗМЕНЕНО: Добавили Auth
  window.firebaseApp = initializeApp(firebaseConfig);
  window.firestore = getFirestore(window.firebaseApp);
  window.firebaseAuth = getAuth(window.firebaseApp); // ИЗМЕНЕНО: Инициализация Auth
  window.firebaseEnabled = true;
  window.firebaseModules = { doc: null, setDoc: null, getDoc: null, deleteDoc: null, signInAnonymously, onAuthStateChanged }; // ИЗМЕНЕНО: Добавили Auth функции
  const firestoreModule = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
  window.firebaseModules.doc = firestoreModule.doc;
  window.firebaseModules.setDoc = firestoreModule.setDoc;
  window.firebaseModules.getDoc = firestoreModule.getDoc;
  window.firebaseModules.deleteDoc = firestoreModule.deleteDoc;
  console.log('Firebase инициализирован');
} catch(e) {
  console.warn('Firebase не инициализирован:', e);
  window.firebaseEnabled = false;
}
/* ---------- ИЗМЕНЕНО: Функция для получения userId (анонимный auth) ---------- */
async function getUserId() {
  return new Promise((resolve) => {
    if (!window.firebaseEnabled || !window.firebaseAuth) {
      // Fallback на старый deviceId, если Auth недоступен
      resolve(getDeviceId());
      return;
    }
    window.firebaseModules.onAuthStateChanged(window.firebaseAuth, (user) => {
      if (user) {
        resolve(user.uid);
      } else {
        window.firebaseModules.signInAnonymously(window.firebaseAuth)
          .then((userCredential) => resolve(userCredential.user.uid))
          .catch((e) => {
            console.warn('Anon auth failed:', e);
            resolve(getDeviceId()); // Fallback
          });
      }
    });
  });
}
/* ---------- Старый getDeviceId (для fallback и миграции) ---------- */
function getDeviceId() {
  let deviceId = localStorage.getItem('device_id');
  if(!deviceId) {
    deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('device_id', deviceId);
  }
  return deviceId;
}
/* ---------- Настройки ---------- */
const BATCH_SIZE = 1888;
const SHOW_ANSWER_MS = 15000;
const STORAGE_KEY = (() => {
  const p = (location.pathname||'/').replace(/^\/|\/$/g,'').replace(/\//g,'_') || 'root';
  return `arabic_trainer_state_v1_${encodeURIComponent(location.hostname + '_' + p)}`;
})();
/* ---------- Состояние ---------- */
let allWords = [];
let orderQueue = [];
let masteredFinal = [];
let practiceHistory = [];
let roundMastered = [];
let practiceAccum = [];
let practiceOrder = [];
let phase = 'learn';
let currentRaw = null;
let modalTimer = null;
/* ---------- DOM ---------- */
const screenDua = document.getElementById('screen-dua');
const screenMain = document.getElementById('screen-main');
const btnDoneDua = document.getElementById('btn-done-dua');
const statTotal = document.getElementById('stat-total');
const statMastered = document.getElementById('stat-mastered');
const statRemaining = document.getElementById('stat-remaining');
const statPhase = document.getElementById('stat-phase');
const arabicDiv = document.getElementById('arabic');
const learnControls = document.getElementById('learn-controls');
const btnKnow = document.getElementById('btn-know');
const btnDont = document.getElementById('btn-dont');
const btnAdd = document.getElementById('btn-add');
const btnReset = document.getElementById('btn-reset');
const messageDiv = document.getElementById('message');
const practiceArea = document.getElementById('practice-area');
const practiceInput = document.getElementById('practice-input');
const practiceSubmit = document.getElementById('practice-submit');
const practiceSkip = document.getElementById('practice-skip');
const oralAnswerBtn = document.getElementById('oral-answer');
const modalRoot = document.getElementById('modal-root');
/* ---------- Утилиты ---------- */
function normalizeRu(s){
  if(!s && s!=='') return '';
  return String(s).trim().toLowerCase().replace(/ё/g,'е').replace(/\s+/g,' ');
}
function normalizeLine(l){ if(!l) return ''; return l.replace(/^\uFEFF/,'').replace(/[\u2010\u2011\u2012\u2013\u2014\u2015–—−]/g,'-').replace(/\s+/g,' ').trim(); }
function parseLine(raw){
  raw = normalizeLine(raw);
  const parts = raw.split(/[-–—]/).map(p=>p.trim()).filter(Boolean);
  const left = parts.length ? parts[0] : '';
  const right = parts.slice(1);
  const rus = left ? left.split(',').map(s=>s.trim()).filter(Boolean) : [];
  const arabParts = right.length ? right.join(' - ').split(/\s*-\s*/).map(s=>s.trim()).filter(Boolean) : [];
  return { rawLine: raw, rus, arabParts, arabFull: right.join(' - ') || '' };
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }
/* ---------- last-letter mistake detector ---------- */
function isLastCharMistake(userRaw, correctRaw){
  const u = normalizeRu(userRaw||'');
  const c = normalizeRu(correctRaw||'');
  if(!u || !c) return false;
  if(u === c) return false;
  if(u.length === c.length){
    if(u.slice(0, -1) === c.slice(0, -1) && u[u.length-1] !== c[c.length-1]) return true;
  }
  if(u.length === c.length - 1){
    if(u === c.slice(0, -1)) return true;
  }
  if(u.length === c.length + 1){
    if(u.slice(0, -1) === c) return true;
  }
  return false;
}
/* ---------- Save / Load / Clear ---------- */
async function saveState(){
  const st = {
    allRaw: allWords.map(w=>w.rawLine),
    orderQueue: orderQueue.slice(),
    masteredFinal: masteredFinal.slice(),
    practiceHistory: practiceHistory.slice(),
    roundMastered: roundMastered.slice(),
    practiceAccum: practiceAccum.slice(),
    practiceOrder: practiceOrder.slice(),
    phase, currentRaw,
    timestamp: Date.now()
  };
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
    localStorage.setItem(STORAGE_KEY + '_backup', JSON.stringify(st));
  }catch(e){ console.warn('localStorage save failed', e); }
  if(window.firebaseEnabled && window.firestore && window.firebaseModules){
    try{
      const userId = await getUserId(); // ИЗМЕНЕНО: Используем userId вместо deviceId
      const firestoreKey = `${userId}_${STORAGE_KEY}`;
      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);
      await window.firebaseModules.setDoc(docRef, st, { merge: true });
    }catch(e){ console.warn('Firestore save failed:', e); }
  }
}
async function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const st = JSON.parse(raw);
      // ИЗМЕНЕНО: Убрали проверку на 24 часа, чтобы всегда загружать
      return st;
    }
  }catch(e){ console.warn('localStorage load failed', e); }
  if(window.firebaseEnabled && window.firestore && window.firebaseModules){
    try{
      const userId = await getUserId(); // ИЗМЕНЕНО: userId
      const firestoreKey = `${userId}_${STORAGE_KEY}`;
      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);
      const docSnap = await window.firebaseModules.getDoc(docRef);
      if(docSnap.exists()){
        const data = docSnap.data();
        try{
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
          localStorage.setItem(STORAGE_KEY + '_backup', JSON.stringify(data));
        }catch(e){}
        return data;
      } else {
        // ИЗМЕНЕНО: Миграция старого прогресса с deviceId
        const oldDeviceId = getDeviceId();
        const oldFirestoreKey = `${oldDeviceId}_${STORAGE_KEY}`;
        const oldDocRef = window.firebaseModules.doc(window.firestore, 'progress', oldFirestoreKey);
        const oldDocSnap = await window.firebaseModules.getDoc(oldDocRef);
        if(oldDocSnap.exists()){
          const oldData = oldDocSnap.data();
          // Переносим в новый ключ
          await window.firebaseModules.setDoc(docRef, oldData, { merge: true });
          await window.firebaseModules.deleteDoc(oldDocRef); // Опционально: чистим старый
          try{
            localStorage.setItem(STORAGE_KEY, JSON.stringify(oldData));
          }catch(e){}
          return oldData;
        }
      }
    }catch(e){ console.warn('Firestore load failed:', e); }
  }
  return null;
}
async function clearState(){
  try{
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(STORAGE_KEY + '_backup');
    localStorage.removeItem('device_id'); // ИЗМЕНЕНО: Чистим deviceId для полноты
  }catch(e){}
  if(window.firebaseEnabled && window.firestore && window.firebaseModules){
    try{
      const userId = await getUserId(); // ИЗМЕНЕНО: userId
      const firestoreKey = `${userId}_${STORAGE_KEY}`;
      const docRef = window.firebaseModules.doc(window.firestore, 'progress', firestoreKey);
      await window.firebaseModules.deleteDoc(docRef);
    }catch(e){ console.warn('Firestore delete failed:', e); }
  }
}
/* ---------- robust fetch ---------- */
async function robustFetchWords(){
  const timestamp = Date.now();
  const tries = ['words.txt','./words.txt'];
  try{ tries.push(location.pathname.replace(/\/[^/]*$/,'/') + 'words.txt'); }catch(e){}
  for(const p of tries){
    try{ const r = await fetch(p + '?_' + timestamp, {cache: 'no-store'}); if(r.ok) return await r.text(); }catch(e){}
  }
  try{
    const user = location.hostname.split('.')[0] || '';
    const repo = (location.pathname.split('/').filter(Boolean)[0] || '');
    if(user && repo){
      const raw = `https://raw.githubusercontent.com/${user}/${repo}/main/words.txt`;
      const r = await fetch(raw + '?_' + timestamp, {cache: 'no-store'});
      if(r.ok) return await r.text();
    }
  }catch(e){}
  throw new Error('Не удалось загрузить words.txt');
}
/* ---------- Инициализация словаря ---------- */
async function initDictionary(){
  const st = await loadState();
  let serverWords = [];
  let serverWordsByRaw = new Map();
  let serverRawSet = new Set();
  try{
    const txt = await robustFetchWords();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    serverWords = lines.map(parseLine);
    serverWords.forEach(w => {
      serverWordsByRaw.set(w.rawLine, w);
      serverRawSet.add(w.rawLine);
    });
  }catch(e){ console.warn('Не удалось загрузить words.txt:', e); }
  if(st && Array.isArray(st.allRaw) && st.allRaw.length){
    allWords = st.allRaw.map(raw => {
      const parsed = parseLine(raw);
      return { rawLine: raw, ...parsed };
    });
    if(serverWords.length > 0 && serverRawSet.size > 0){
      allWords = allWords.filter(w => serverRawSet.has(w.rawLine));
      orderQueue = (Array.isArray(st.orderQueue) ? st.orderQueue.filter(r => serverRawSet.has(r)) : []);
      masteredFinal = (Array.isArray(st.masteredFinal) ? st.masteredFinal.filter(r => serverRawSet.has(r)) : []);
      practiceHistory = (Array.isArray(st.practiceHistory) ? st.practiceHistory.filter(r => serverRawSet.has(r)) : []);
      roundMastered = (Array.isArray(st.roundMastered) ? st.roundMastered.filter(r => serverRawSet.has(r)) : []);
      practiceAccum = (Array.isArray(st.practiceAccum) ? st.practiceAccum.filter(r => serverRawSet.has(r)) : []);
      practiceOrder = (Array.isArray(st.practiceOrder) ? st.practiceOrder.filter(r => serverRawSet.has(r)) : []);
      const changedWords = [];
      allWords.forEach((existingWord, index) => {
        if(serverRawSet.has(existingWord.rawLine)){
          const serverWord = serverWordsByRaw.get(existingWord.rawLine);
          if(JSON.stringify(existingWord.rus) !== JSON.stringify(serverWord.rus) || JSON.stringify(existingWord.arabParts) !== JSON.stringify(serverWord.arabParts)){
            allWords[index] = serverWord;
            changedWords.push(serverWord.rawLine);
          }
        }
      });
      changedWords.forEach(rawLine => {
        masteredFinal = masteredFinal.filter(r => r !== rawLine);
        practiceHistory = practiceHistory.filter(r => r !== rawLine);
        roundMastered = roundMastered.filter(r => r !== rawLine);
        practiceAccum = practiceAccum.filter(r => r !== rawLine);
        practiceOrder = practiceOrder.filter(r => r !== rawLine);
        if(!orderQueue.includes(rawLine)) orderQueue.push(rawLine);
      });
    } else {
      orderQueue = st.orderQueue || [];
      masteredFinal = st.masteredFinal || [];
      practiceHistory = st.practiceHistory || [];
      roundMastered = st.roundMastered || [];
      practiceAccum = st.practiceAccum || [];
      practiceOrder = st.practiceOrder || [];
    }
    phase = st.phase || 'learn';
    currentRaw = (st.currentRaw && serverRawSet.has(st.currentRaw)) ? st.currentRaw : null;
  } else {
    if(serverWords.length > 0){
      allWords = serverWords.slice();
      masteredFinal = []; practiceHistory = []; roundMastered = []; practiceAccum = []; practiceOrder = [];
      phase = 'learn'; currentRaw = null;
      orderQueue = allWords.map(w=>w.rawLine);
      shuffle(orderQueue);
    }
  }
  updateStats();
  saveState().catch(e => console.warn('Save failed:', e));
}
/* ---------- UI helpers ---------- */
function updateStats(){
  statTotal.textContent = allWords.length;
  statMastered.textContent = masteredFinal.length;
  statRemaining.textContent = orderQueue.length;
  statPhase.textContent = phase === 'learn' ? 'Заучивание' : (phase === 'practice' ? 'Практика' : '—');
}
function showMessage(t){ messageDiv.textContent = t || ''; }
/* ---------- Заучивание ---------- */
function showNextLearn(){
  phase = 'learn';
  learnControls.classList.remove('hidden');
  practiceArea.classList.add('hidden');
  updateStats();
  if(orderQueue.length === 0){
    if(practiceAccum.length >= BATCH_SIZE){
      startPractice();
      return;
    }
    arabicDiv.textContent = 'Очередь пуста.';
    showMessage('Добавьте слова или сбросьте прогресс.');
    return;
  }
  currentRaw = orderQueue[0];
  const obj = allWords.find(w=>w.rawLine===currentRaw) || {rus:[], arabParts:[]};
  arabicDiv.textContent = obj.arabFull || (obj.arabParts||[]).join(' - ') || '[нет арабского]';
  showMessage('Нажмите «Знаю» или «Не знаю».');
  saveState();
}
/* ---------- Кнопки заучивания ---------- */
btnKnow.addEventListener('click', () => {
  if(!currentRaw) return;
  orderQueue.shift();
  if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);
  if(!practiceAccum.includes(currentRaw)) practiceAccum.push(currentRaw);
  currentRaw = null;
  if (practiceAccum.length >= BATCH_SIZE) {
    startPractice();
  } else {
    showNextLearn();
  }
});
btnDont.addEventListener('click', () => {
  if(!currentRaw) return;
  orderQueue.shift();
  if(!practiceAccum.includes(currentRaw)) practiceAccum.push(currentRaw);
  const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);
  showDontKnowModal(obj);
  currentRaw = null;
});
/* ---------- Modal: "Не знаю" ---------- */
function showDontKnowModal(obj){
  closeModal();
  const overlay = document.createElement('div'); overlay.className='overlay';
  const modal = document.createElement('div'); modal.className='modal';
  let html = '';
  const ar = obj.arabParts && obj.arabParts.length ? obj.arabParts : (obj.arabFull?obj.arabFull.split(/\s*-\s*/).map(s=>s.trim()):[]);
  if(obj.rus.length && ar.length && obj.rus.length === ar.length){
    for(let i=0;i<obj.rus.length;i++) html += `<div class="pair">${escapeHtml(obj.rus[i])} — <span style="direction:rtl">${escapeHtml(ar[i])}</span></div>`;
  } else {
    const arabAll = ar.join(' - ');
    for(const r of obj.rus.length?obj.rus:['']) html += `<div class="pair">${escapeHtml(r)} — <span style="direction:rtl">${escapeHtml(arabAll)}</span></div>`;
  }
  modal.innerHTML = `<div><strong>Перевод (показывается 15 с)</strong></div><div style="margin-top:8px">${html}</div>`;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);
  modalTimer = setTimeout(()=>{
    closeModal();
    if(practiceAccum.length >= BATCH_SIZE){
      startPractice();
    } else {
      showNextLearn();
    }
  }, SHOW_ANSWER_MS);
}
/* ---------- Modal: практика — при ошибке и мелкой ошибке ---------- */
function showPracticeAnswerModal(obj, title = 'Правильный ответ', autoClose = true, onClose = null){
  closeModal();
  const overlay = document.createElement('div'); overlay.className='overlay';
  const modal = document.createElement('div'); modal.className='modal';
  let html = '';
  const ar = obj.arabParts && obj.arabParts.length ? obj.arabParts : (obj.arabFull?obj.arabFull.split(/\s*-\s*/).map(s=>s.trim()):[]);
  if(obj.rus.length && ar.length && obj.rus.length === ar.length){
    for(let i=0;i<obj.rus.length;i++) html += `<div class="pair">${escapeHtml(obj.rus[i])} — <span style="direction:rtl">${escapeHtml(ar[i])}</span></div>`;
  } else {
    const arabAll = ar.join(' - ');
    for(const r of obj.rus.length?obj.rus:['']) html += `<div class="pair">${escapeHtml(r)} — <span style="direction:rtl">${escapeHtml(arabAll)}</span></div>`;
  }
  modal.innerHTML = `<div><strong>${escapeHtml(title)}</strong></div><div style="margin-top:8px">${html}</div><div style="text-align:right;margin-top:12px"><button id="modal-close" class="button">Закрыть (Esc)</button></div>`;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);
  function cleanup(){ if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } document.removeEventListener('keydown', onKey); overlay.removeEventListener('click', onOverlay); const b=document.getElementById('modal-close'); if(b) b.removeEventListener('click', onBtn); if(overlay.parentNode) overlay.parentNode.removeChild(overlay); practiceInput.focus(); }
  function onKey(e){ if(e.key==='Escape') onBtn(); }
  function onOverlay(e){ if(e.target===overlay) onBtn(); }
  function onBtn(){ cleanup(); if(onClose) onClose(); else showNextPractice(); }
  document.addEventListener('keydown', onKey);
  overlay.addEventListener('click', onOverlay);
  const btn = document.getElementById('modal-close'); if(btn) btn.addEventListener('click', onBtn);
  if(autoClose) modalTimer = setTimeout(()=>{ onBtn(); }, SHOW_ANSWER_MS);
}
/* ---------- Практика: старт ---------- */
function startPractice(){
  phase = 'practice';
  learnControls.classList.add('hidden');
  practiceArea.classList.remove('hidden');
  let newWords = practiceAccum.slice(0, BATCH_SIZE);
  let practiceWords = masteredFinal.filter(word => !roundMastered.includes(word));
  practiceOrder = newWords.concat(practiceWords);
  if(practiceWords.length > 1) {
    const shuffled = practiceWords.slice();
    shuffle(shuffled);
    practiceOrder = newWords.concat(shuffled);
  }
  practiceAccum = [];
  roundMastered = [];
  updateStats();
  showNextPractice();
  saveState();
}
/* ---------- showNextPractice ---------- */
function showNextPractice(){
  if(practiceOrder.length === 0){
    roundMastered = [];
    phase = 'learn';
    learnControls.classList.remove('hidden');
    practiceArea.classList.add('hidden');
    updateStats();
    showNextLearn();
    saveState();
    return;
  }
  currentRaw = practiceOrder.shift();
  const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);
  arabicDiv.textContent = obj.arabFull || (obj.arabParts||[]).join(' - ') || '[нет арабского]';
  practiceInput.value = '';
  practiceInput.focus();
  oralAnswerBtn.classList.remove('hidden');
  updateStats();
}
/* ---------- Устный ответ ---------- */
oralAnswerBtn.addEventListener('click', () => {
  if(!currentRaw) return;
  const isOld = masteredFinal.includes(currentRaw);
  if(!isOld) {
    masteredFinal.push(currentRaw);
    practiceHistory.push(currentRaw);
  }
  if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);
  showMessage('Засчитано как верный (устно)');
  currentRaw = null;
  showNextPractice();
  saveState();
});
/* ---------- Практика: проверка ---------- */
function enablePracticeControls(){ practiceSubmit.disabled=false; practiceSkip.disabled=false; practiceInput.disabled=false; practiceInput.focus(); }
function disablePracticeControls(){ practiceSubmit.disabled=true; practiceSkip.disabled=true; practiceInput.disabled=true; }
practiceSubmit.addEventListener('click', () => {
  if(!currentRaw) return;
  disablePracticeControls();
  try{
    const val = (practiceInput.value||'').trim();
    if(!val){ enablePracticeControls(); return; }
    const obj = allWords.find(w=>w.rawLine===currentRaw) || parseLine(currentRaw);
    const userNorm = normalizeRu(val);
    const exact = (obj.rus||[]).some(r => normalizeRu(r) === userNorm);
    const almost = !exact && (obj.rus||[]).some(r => isLastCharMistake(userNorm, normalizeRu(r)));
    const isOld = masteredFinal.includes(currentRaw);
    const markAsCorrect = () => {
      if(!roundMastered.includes(currentRaw)) roundMastered.push(currentRaw);
      if(!masteredFinal.includes(currentRaw)) masteredFinal.push(currentRaw);
      if(!practiceHistory.includes(currentRaw)) practiceHistory.push(currentRaw);
      updateStats();
      saveState();
    };
    if(exact){
      markAsCorrect();
      showMessage('Верно — отмечено как окончательно выученное.');
      currentRaw = null;
      enablePracticeControls();
      showNextPractice();
    } else if(almost){
      markAsCorrect();
      showPracticeAnswerModal(obj, 'Мелкая ошибка — засчитано', true, () => {
        currentRaw = null;
        enablePracticeControls();
        showNextPractice();
      });
    } else {
      if(isOld){
        practiceOrder.unshift(currentRaw);
      } else {
        orderQueue.unshift(currentRaw);
        if(masteredFinal.includes(currentRaw)){
          masteredFinal = masteredFinal.filter(r=>r!==currentRaw);
          practiceHistory = practiceHistory.filter(r=>r!==currentRaw);
        }
      }
      showPracticeAnswerModal(obj, 'Неправильно', true);
      currentRaw = null;
      enablePracticeControls();
    }
  }catch(e){ console.error(e); enablePracticeControls(); }
});
practiceInput.addEventListener('keydown', e => { if(e.key==='Enter'){ e.preventDefault(); practiceSubmit.click(); }});
practiceSkip.addEventListener('click', () => {
  if(!currentRaw) return;
  const isOld = masteredFinal.includes(currentRaw);
  if(isOld){
    practiceOrder.unshift(currentRaw);
  } else {
    orderQueue.unshift(currentRaw);
    if(masteredFinal.includes(currentRaw)){
      masteredFinal = masteredFinal.filter(r => r !== currentRaw);
      practiceHistory = practiceHistory.filter(r => r !== currentRaw);
    }
  }
  currentRaw = null;
  showNextPractice();
  saveState();
});
/* ---------- Добавить новые слова ---------- */
btnAdd.addEventListener('click', async () => {
  try{
    const txt = await robustFetchWords();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const serverWords = lines.map(parseLine);
    const existing = new Set(allWords.map(w => w.rawLine));
    let added = 0;
    for(const w of serverWords){
      if(!existing.has(w.rawLine)){
        allWords.push(w);
        orderQueue.push(w.rawLine);
        existing.add(w.rawLine);
        added++;
      }
    }
    if(added){
      shuffle(orderQueue);
      updateStats();
      alert('Добавлено новых слов: ' + added);
      saveState();
    } else {
      alert('Новых слов не найдено');
    }
  }catch(e){ alert('Ошибка: '+e.message); }
});
/* ---------- Сброс прогресса ---------- */
function showResetModal() {
  closeModal();
  const overlay = document.createElement('div'); overlay.className = 'overlay';
  const modal = document.createElement('div'); modal.className = 'modal';
  modal.innerHTML = `
    <div><strong>Подтверждение сброса</strong></div>
    <div style="margin-top:12px">Вы уверены? Всё будет потеряно.</div>
    <div style="text-align:right;margin-top:16px">
      <button id="modal-cancel" style="margin-right:8px">Отмена</button>
      <button id="modal-confirm" class="btn-danger">Да, сбросить</button>
    </div>
  `;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);
  const cleanup = () => { overlay.remove(); document.removeEventListener('keydown', onKey); };
  const onKey = e => { if(e.key==='Escape') cleanup(); };
  const onCancel = () => cleanup();
  const onConfirm = async () => {
    cleanup();
    await clearState();
    orderQueue = allWords.map(w=>w.rawLine); shuffle(orderQueue);
    masteredFinal = []; practiceHistory = []; roundMastered = []; practiceAccum = []; practiceOrder = []; phase='learn'; currentRaw=null;
    screenMain.classList.add('hidden'); screenDua.classList.remove('hidden');
    updateStats();
    showMessage('Прогресс сброшен.');
  };
  document.addEventListener('keydown', onKey);
  document.getElementById('modal-cancel').addEventListener('click', onCancel);
  document.getElementById('modal-confirm').addEventListener('click', onConfirm);
}
btnReset.addEventListener('click', showResetModal);
/* ---------- "Я сделал дуа" — ИСПРАВЛЕНО ---------- */
btnDoneDua.addEventListener('click', async () => {
  screenDua.classList.add('hidden');
  screenMain.classList.remove('hidden');
  if(!allWords.length) {
    try {
      await initDictionary();
    } catch(e) {
      console.warn('initDictionary failed:', e);
      showMessage('Не удалось загрузить слова. Проверьте интернет.');
    }
  }
  if(phase === 'practice'){
    learnControls.classList.add('hidden');
    practiceArea.classList.remove('hidden');
    showNextPractice();
  } else {
    practiceArea.classList.add('hidden');
    learnControls.classList.remove('hidden');
    showNextLearn();
  }
});
/* ---------- bootstrap ---------- */
(async function bootstrap(){
  try{ await initDictionary(); screenDua.classList.remove('hidden'); screenMain.classList.add('hidden'); }catch(e){ console.error(e); }
})();
window.addEventListener('beforeunload', saveState);
window.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveState(); });
function closeModal(){ modalRoot.innerHTML=''; if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } }
</script>
</head>
<body>
  <h1>Тренажёр арабских слов</h1>
  <div id="screen-dua" class="dua">
    <div><strong>Перед началом тренировок</strong></div>
    <div class="arab">رَّبِّ زِدْنِى عِلْمًۭا</div>
    <div style="text-align:center;margin-top:6px">Перевод: «Господь мой! Приумножь мои знания»</div>
    <div style="text-align:center;margin-top:12px">
      <button id="btn-done-dua">Я сделал дуа</button>
    </div>
  </div>
  <div id="screen-main" class="hidden">
    <div class="stats">
      <div class="stat">Всего: <span id="stat-total">0</span></div>
      <div class="stat">Оконч. выучено: <span id="stat-mastered">0</span></div>
      <div class="stat">В очереди: <span id="stat-remaining">0</span></div>
      <div class="stat">Фаза: <span id="stat-phase">—</span></div>
    </div>
    <div id="arabic">…</div>
    <div id="learn-controls" class="controls">
      <button id="btn-know" class="btn-primary">Знаю</button>
      <button id="btn-dont">Не знаю</button>
    </div>
    <div class="controls-vertical">
      <div class="controls">
        <button id="btn-reset" class="btn-danger">Сбросить прогресс</button>
        <button id="btn-add">Добавить новые слова</button>
      </div>
    </div>
    <div id="practice-area" class="hidden" style="margin-top:12px">
      <div style="margin-bottom:8px"><strong>Практика — введите перевод на русском:</strong></div>
      <input id="practice-input" type="text" autocomplete="off" placeholder="Введите перевод" />
      <div class="controls" style="margin-top:8px">
        <button id="practice-submit">Проверить</button>
        <button id="practice-skip">Пропустить</button>
        <button id="oral-answer" class="btn-primary hidden">Ответил устно</button>
      </div>
    </div>
    <div id="message" class="small" style="margin-top:12px"></div>
  </div>
  <div id="modal-root"></div>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;color:#111;background:#fff;max-width:980px}
  .dua{background:#fff;padding:14px;border-radius:10px;border:1px solid #eee;margin-bottom:12px}
  .arab{direction:rtl;font-size:2.2rem;font-weight:700;margin:8px 0;text-align:center}
  #arabic{direction:rtl;font-size:2.6rem;text-align:center;min-height:3.6em;padding:14px;border-radius:8px;border:1px solid #eee}
  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  .controls-vertical{display:block;text-align:center;margin-top:10px}
  .controls-vertical .controls{justify-content:center}
  button{padding:10px 12px;border-radius:8px;border:1px solid #ccc;background:#f6f6f6;cursor:pointer}
  .btn-primary{background:#e6fff0;border-color:#b6f0c7}
  .btn-danger{background:#fff0f0;border-color:#f0b6b6}
  .small{font-size:0.95rem;color:#666;margin-top:8px;text-align:center}
  .hidden{display:none}
  input[type="text"]{width:100%;padding:10px;border-radius:8px;border:1px solid #ddd;box-sizing:border-box}
  .stats{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-bottom:8px}
  .stat{background:#fafafa;padding:8px 12px;border-radius:8px;border:1px solid #f0f0f0}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:9999}
  .modal{background:#fff;padding:16px;border-radius:8px;max-width:720px;width:92%;box-shadow:0 8px 30px rgba(0,0,0,0.2)}
  .modal .pair{margin-top:8px}
</style>
</body>
</html>
